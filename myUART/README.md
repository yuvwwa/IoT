# UART на GPIO с использованием Timer1 и прерываний (AVR)

## Описание проекта

Этот проект реализует **асинхронный UART** на микроконтроллере AVR без использования аппаратного USART. Передача (TX) и приём (RX) данных осуществляется с помощью:

* **GPIO** (TX и RX пины),
* **Аппаратного таймера Timer1**,
* **Внешних и таймерных прерываний**.

Поддерживается стандартный формат UART **8N1** (8 бит данных, без чётности, 1 стоп-бит).

## Основная архитектура

### Настройка пинов

```c
#define PIN_TX 3
#define PIN_RX 2

DDRD |= _BV(PIN_TX);   // TX - выход
PORTD |= _BV(PIN_TX);  // высокий по умолчанию
DDRD &= ~_BV(PIN_RX);  // RX - вход
PORTD |= _BV(PIN_RX);  // подтяжка
```

---

### API

```c
void uart_set_baudrate(int rate);          // установка скорости
void uart_send(char b);                    // отправка одного байта
uint8_t uart_available();                  // байты в RX-буфере
char uart_read();                          // чтение одного байта
bool uart_read_string(char *rx_data);      // чтение всех байт
```

---

### Принцип работы

* **TX:** таймер посылает старт-бит, 8 бит данных и стоп-бит.
* **RX:** внешнее прерывание фиксирует старт-бит, таймер считывает биты и кладёт байт в RX-буфер.
* Все операции работают **асинхронно**, основной код только читает и пишет буферы.

---

### Использование

```c
void loop() {
    char buf[65];

    if (uart_read_string(buf)) {
        Serial.print(buf);
    }

    if (Serial.available()) {
        uart_send(Serial.read());
    }
}
```

## Особенности

* RX имеет приоритет: данные нельзя терять.
* Таймер обеспечивает точные интервалы битов.
* Кольцевые буферы хранят данные до обработки.
* ISR минимальны и эффективны, без задержек (`delay()`).

## Визуализация работы

Видео-демонстрацию на реальном микроконтроллере можно посмотреть по ссылке (https://disk.yandex.ru/i/Kc8KJNplDD-H5g)

Ссылка на tinkercad с работающей симуляцией всей схемы и кода (https://www.tinkercad.com/things/iaipL1X0ngv-uart?sharecode=dUUrItNY0DcXupK9VCaTo66q_PLDCFvyW3QANKSODN0)

## Вывод

Этот проект демонстрирует, как реализовать UART полностью на программном уровне, используя только GPIO, таймер и прерывания.