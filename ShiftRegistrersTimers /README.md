# Управление семисегментными индикаторами через каскадные сдвиговые регистры

## Описание проекта

Это система управления двумя семисегментными индикаторами с использованием сдвиговых регистров 74HC595. Проект реализует секундомер (00-59), который можно устанавливать через Serial порт. Вместо 16 пинов Arduino используется всего 3 благодаря каскадному соединению регистров.

**Демонстрация:**
-  [Симуляция в Tinkercad](https://www.tinkercad.com/things/c2Fkk9hwk5X/editel)

---

## Как это работает

### Основная идея

Сдвиговый регистр 74HC595 превращает последовательный поток данных в параллельный вывод. Мы отправляем биты один за другим через одну линию (DATA), синхронизируем их тактовым сигналом (CLOCK), а затем фиксируем на выходах сигналом LATCH.

При каскадировании двух регистров первый байт "проталкивается" во второй регистр, поэтому мы отправляем 16 бит подряд:

```
Байт 1 (десятки) → проталкивается во второй регистр
Байт 2 (единицы) → остается в первом регистре
LATCH → оба регистра выводят данные одновременно
```

### Схема подключения

```
Arduino D7  → DATA  (DS pin 14) первого 74HC595
Arduino D3  → CLOCK (SHCP pin 11) обоих регистров
Arduino D5  → LATCH (STCP pin 12) обоих регистров

74HC595 #1 Q7' (pin 9) → DS (pin 14) 74HC595 #2

Каждый регистр:
- VCC (pin 16) → 5V
- GND (pin 8) → GND
- OE (pin 13) → GND
- MR (pin 10) → VCC
```

### Семисегментный индикатор

Используется индикатор с **общим анодом** (общий вывод к +5V). Каждый сегмент загорается при подаче LOW (0V).

```
     A
    ═══
  F║   ║B
    ═G═
  E║   ║C
    ═══  
     D
```

Кодировка для общего анода (0 = сегмент горит):

```cpp
const uint8_t SEGMENTS_CODE[10] = {
  0b10111011,  // 0
  0b00001010,  // 1
  0b01110011,  // 2
  0b01011011,  // 3
  0b11001010,  // 4
  0b11011001,  // 5
  0b11111101,  // 6
  0b00001011,  // 7
  0b11111011,  // 8
  0b11011111   // 9
};
```

---

## Программная реализация

### Архитектура

Программа состоит из трех основных компонентов:

1. **Timer1 с прерыванием** — генерирует события каждую секунду
2. **ISR (обработчик прерывания)** — обновляет счетчик и дисплей
3. **loop()** — читает данные из Serial

### Timer1: точная секунда

Используется режим CTC (Clear Timer on Compare Match):

```
Частота = 16 МГц / (prescaler × (OCR1A + 1))
        = 16 000 000 / (1024 × 15625)
        = 1 Гц
```

Настройка:
```cpp
TCCR1B |= (1 << WGM12);              // Режим CTC
TCCR1B |= (1 << CS12) | (1 << CS10); // Prescaler 1024
OCR1A = 15624;                       // Значение сравнения
TIMSK1 |= (1 << OCIE1A);             // Включить прерывание
```

### Обработчик прерывания

Вызывается каждую секунду и выполняет:

```cpp
ISR(TIMER1_COMPA_vect) {
  // 1. Проверить, есть ли новое значение от пользователя
  if (userInput != -1) {
    displayValue = userInput;  // Показать его на этом тике
    userInput = -1;            // Сбросить
  } else {
    timeCounter++;             // Инкремент счетчика
    if (timeCounter >= 60) {
      timeCounter = 0;
    }
    displayValue = timeCounter;
  }
  
  // 2. Обновить дисплеи
  refreshDisplay(displayValue);
}
```

### Передача данных в регистры

```cpp
void shiftOutByte(uint8_t data) {
  for (int8_t i = 7; i >= 0; i--) {
    // Установить бит данных
    if (data & (1 << i)) {
      DATA_PORT |= DATA_BIT;   // HIGH
    } else {
      DATA_PORT &= ~DATA_BIT;  // LOW
    }
    
    // Тактовый импульс
    CLOCK_PORT |= CLOCK_BIT;   // HIGH
    CLOCK_PORT &= ~CLOCK_BIT;  // LOW
  }
}

void refreshDisplay(uint8_t value) {
  uint8_t tens = value / 10;
  uint8_t ones = value % 10;
  
  LATCH_PORT &= ~LATCH_BIT;           // LATCH LOW
  shiftOutByte(encodeDigit(tens));    // Десятки
  shiftOutByte(encodeDigit(ones));    // Единицы
  LATCH_PORT |= LATCH_BIT;            // LATCH HIGH
}
```

### Обработка Serial ввода

Используется неблокирующий алгоритм с таймаутом:

```cpp
void loop() {
  static char buffer[4];
  static uint8_t pos = 0;
  static unsigned long lastTime = 0;
  
  if (Serial.available() > 0) {
    char c = Serial.read();
    if (isDigit(c) && pos < 2) {
      buffer[pos++] = c;
      lastTime = millis();
    }
  }
  
  // Обработка по таймауту (25 мс после последнего символа)
  if (pos > 0 && (millis() - lastTime > 25)) {
    buffer[pos] = '\0';
    int value = atoi(buffer);
    
    cli();               // Отключить прерывания
    userInput = value;   // Передать в ISR
    sei();               // Включить прерывания
    
    pos = 0;             // Сбросить буфер
  }
}
```

---

## Логика работы системы

### Диаграмма взаимодействия

```
СЕКУНДЫ: 0---1---2---3---4---5---6---7---8---9---10--11--12

USER:    -----------v------------------v-----------------
              send(42)             send(10)
                 |                     |
MCU:     0---1---42--43--44--45--46--10--11--12--13--14--15
```

**Ключевая особенность:** пользовательское значение **заменяет** следующее значение счетчика, а не устанавливает его напрямую.

### Инициализация системы

При включении система ждет первого значения от пользователя:

```cpp
if (!isInitialized) {
  if (receivedValue != -1) {
    timeCounter = receivedValue;
    isInitialized = true;
  }
}
```

Только после получения первого значения начинается автоматический отсчет.

### Безопасный обмен данными

Переменная `userInput` используется для передачи данных между `loop()` и `ISR`. Для предотвращения гонок используются атомарные операции:

```cpp
// В loop() при отправке данных в ISR
cli();                 // Отключить прерывания
userInput = value;     // Записать
sei();                 // Включить прерывания

// В ISR при чтении
cli();
receivedValue = userInput;
userInput = -1;        // Сбросить после чтения
sei();
```

---

## Тестирование

### Проверка в Tinkercad

1. Открыть симуляцию по ссылке
2. Нажать "Start Simulation"
3. Открыть Serial Monitor
4. Индикатор показывает "00"
5. Отправить число (например, "10")
6. Счетчик начинает отсчет: 10 → 11 → 12 → ...


## Выводы

Проект демонстрирует эффективное решение задачи расширения портов ввода-вывода микроконтроллера с использованием каскадных сдвиговых регистров. Применение аппаратных таймеров обеспечивает высокую точность отсчета времени, а неблокирующая архитектура позволяет системе оставаться отзывчивой к внешним событиям.

Реализованная система может служить основой для создания более сложных устройств: цифровых часов, таймеров, измерительных приборов и систем индикации в промышленной автоматике.

